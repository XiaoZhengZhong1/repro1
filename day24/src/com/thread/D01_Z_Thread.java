package com.thread;


public class D01_Z_Thread {
	/*###24.01_多线程(多线程的引入)(了解)
	* 1.什么是线程
		* 线程是程序执行的一条路径, 一个进程中可以包含多条线程
		* 多线程并发执行可以提高程序的效率, 可以同时完成多项工作
	* 2.多线程的应用场景
		* 红蜘蛛同时共享屏幕给多个电脑
		* 迅雷开启多条线程一起下载
		* QQ同时和多个人一起视频
		* 服务器同时处理多个客户端请求
		
	###24.02_多线程(多线程并行和并发的区别)(了解)
	* 并行就是两个任务同时运行，就是甲任务进行的同时，乙任务也在进行。(需要多核CPU)
	* 并发是指两个任务都请求运行，而处理器只能按受一个任务，就把这两个任务安排轮流进行，由于时间间隔较短，使人感觉两个任务都在运行。
	* 比如我跟两个网友聊天，左手操作一个电脑跟甲聊，同时右手用另一台电脑跟乙聊天，这就叫并行。
	* 如果用一台电脑我先给甲发个消息，然后立刻再给乙发消息，然后再跟甲聊，再跟乙聊。这就叫并发。

	###24.03_多线程(Java程序运行原理和JVM的启动是多线程的吗)(了解)
	* A:Java程序运行原理
		* Java命令会启动java虚拟机，启动JVM，等于启动了一个应用程序，也就是启动了一个进程。该进程会自动启动一个 “主线程” ，然后主线程去调用某个类的 main 方法。
		
* B:JVM的启动是多线程的吗---注意(如果两个线程运行语句太少,计算机JVM虚拟机会瞬间完成各自线程的运行,一前一后.没有交叉执行,看不出运行效果
* 因为自己继承的Thread线程子类,start()开启需要时间,哪怕是0.00001秒的时间,在没开启之前,主方法线程会先执行主方法的输出语句,所有如果
* 输出语句很少,以虚拟机的运行速度会瞬间完成.自启线程开启后再执行输出,没有交叉执行,看不出多线程效果.)
		* JVM启动至少启动了垃圾回收线程和主线程，所以是多线程的。
		* 因为当垃圾足够多的时候,JVM虚拟机会一边执行主方法线程,一边执行垃圾回收
		* 线程,当主方法线程垃圾足够多时,垃圾回收线程会回收一次,主方法线程再次创建出足够多的垃圾时.垃圾回收线程会再次回收.所有是一边
		* 运行主方法线程一边运行垃圾回收线程.是多线程.如果是等主方法线程执行完,在执行垃圾回收线程,那就是单线程.(如果主方法垃圾太少,不
		* 够垃圾回收数量,垃圾回收线程是不会自动启动的),注意垃圾回收线程是自动启动的,当垃圾足够多时自动回收,不走回垃圾收站

	###24.04_多线程(多线程程序实现的方式1)(掌握)
	* 1.继承Thread
		* 定义类继承Thread
		* 重写run方法
		* 把新线程要做的事写在run方法中
		*在主方法中 创建线程对象
		* 调用Thread的start()启动线程方法,开启新线程, 内部会自动执行run方法*/
//下面就是多线程,两个线程,一个测试类主方法线程,一个自己开启的线程子类A类线程.运行时两个类的输出语句交叉输出,表示两个线程在各自执行.
	public static void main(String[] args) {
		A aa = new A();		//创建多线程子类A类的对象.
			aa.start();		//开启多线程.
	for (int i = 0; i < 1000; i++) {	
		System.out.println("abcd");
	}
	}
	
	
}
class A extends Thread {		//实现多线程的方法:继承Thread类.
	public void run(){			//重写run()方法.
		for (int i = 0; i < 1000; i++) {	//方法中可以有自己的执行语句.
			System.out.println("12334");
		}
	}
}
