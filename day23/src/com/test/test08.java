package com.test;

import java.util.ArrayList;

public class test08 {
/*###23.08_集合练习(约瑟夫环)
* 幸运数字
* 话说,从前有个国王,有一天心血来潮,把500个死囚都叫出来,让围成一个圈,从1站到500,从1开始数数,数到3和3的倍数就执行死刑直到剩下最后一个.
* 1:分析,我们需要一个方法获取最后活下来的幸运数字.写个getNum()自动生成方法.
* 2:创建一个ArrayList集合来装500个人(因为集合可以删除代替行刑),集合的长度由方法调用赋值getNum(500),
* 3:往集合里添加500个人,按索顺序添加,所以要在for循环中添加,从 i= 0循环到i<=num,把add(i)到集合0索引.
* 4:定义一个变量,int in = 1;来个for循环遍历集合(i = 0;集合.size != 1;i++ ).因为当集合长度等于1时,就只要一个索引0了,
* 数到集合的最大长度时,索引归零,重新开始数,循环中in++,循环一次加一次,因为集合的0索引对应的是第一个人.当循环3次时是第3个人,in++也=3,
* 5:循环中if判断,让in摸鱼% 3 == 0,就remove(索引--),注意删除索引一定要减减,表示回到原索引重新数,因为ArrayList集合底层是数组
* 实现的删除,和添加后,会整体向后和向前移动.
* 6:循环结束后获取集合中的最后一个幸运数字 集合.get(0)
* */
	public static void main(String[] args) {
		System.out.println(getNum(8));
	}
 
   public static int getNum(int num) {
	   ArrayList<Integer> AL = new ArrayList<>();
	   for (int i = 1; i <= num; i++) {	//1代表第一个人.
		   AL.add(i);
   }
	   int in = 1;	//计数器
	   for (int i = 0; AL.size() != 1;i++) {//因为只要一个幸运数字,按照底层依赖数组原理,删除一个会整体向后缩.最后一个就是0.
		   if(i == AL.size()){	//如果索引到最后
			   i = 0;			//就从0索引重新开始.	
		   }
		   
		   if(in % 3 == 0){		//表示in++一次,代表循环一次,代表索引向前数了一次.加到3,6,9.....摸鱼3就是0.
			AL.remove(i--);		//等于0就删除该索引,代表执行一个死刑,删除后数组会向后缩一个索引,索引i要减减.
		   }
		   in++;	//注意计数器的位置,一定要在此处.因为in = 1代表第一个人,每个人都要摸鱼3,看是否要行刑.摸鱼过后再加加代表第二个人
		 
	   }
	   return AL.get(0);  
	
   }
   
}
